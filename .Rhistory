crossover<-function(parent1, parent2)
{
a<-runif(1)
parent1$x<-a*parent1$x+(1-a)*parent2$x
parent1$y<-a*parent1$y+(1-a)*parent2$y
#parent1$sigma_x<-a*parent1$sigma_x+(1-a)*parent2$sigma_x
#parent1$sigma_y<-a*parent1$sigma_y+(1-a)*parent2$sigma_y
return (parent1)
}
## particle swarm
## antlion
## the engine
aggregatedOperator<-function(history, oldModel)
{
selectedPoints<-selection(history, oldModel)
newModel<-modelUpdate(selectedPoints, oldModel)
newPoints<-variation(selectedPoints, newModel)
return (list(newPoints=newPoints,newModel=newModel))
}
metaheuristicRun<-function(initialization, startPoints, termination, evaluation)
{
history<-initialization(startPoints)
history<-evaluateList(history, evaluation)
# model<-initModel(history)
#while (!termination(history,model))
#{
#  aa<-aggregatedOperator(history, model)
#  aa$newPoints<-evaluateList(aa$newPoints, evaluation)
#  history<-historyPush(history,aa$newPoints)
#  model<-aa$newModel
#}
#return(history)
}
historyPush<-function(oldHistory, newPoints)
{
newHistory<-c(oldHistory,newPoints)
return (newHistory)
}
historyPop<-function(history, number)
{
stop=length(history)
start=max(stop-number+1,1)
return(history[start:stop])
}
evaluateList<-function(points,evaluation)
{
for (i in 1:length(points$x)) {
points$quality[[i]]<-evaluation(points$x[[i]], points$y[[i]])
}
return (points)
}
#commonFunctions
mi<-10
generateStartPoints<-function(mi)
{
startPoints<-data.frame(sigma_x=numeric(mi), sigma_y=numeric(mi), x=numeric(mi), y=numeric(mi), minimum=numeric(mi))
for (i in 1:mi)
{
startPoints$x[i]<-runif(1, -512, 512)
startPoints$y[i]<-runif(1, -512, 512)
startPoints$sigma_x[i]<-0.2
startPoints$sigma_y[i]<-0.2
startPoints$minimum[i]<-1000.0
startPoints$best_minimum[i]<-1000.0
}
return (startPoints)
}
termination<-function(i, n)
{
if (i <= n) {
return (F)
}
else {
return (T)
}
}
evaluation<-function(x, y)
{
return(x^2 + y^2)
}
initialization<-function(points){
historyPoints<-data.frame(points)
return (historyPoints)
}
########## funtion
library(ggplot2)
startPoints<-generateStartPoints(mi)
objectx<-metaheuristicRun(initialization, startPoints, termination, evaluation)
print(qplot(objectx$quality))
#bla<-termination(3,2)
print(objectx)
## evolutionary
selection<-function(history, model)
{
return(selectedPoints)
}
modelUpdate<-function(selectedPoints, oldModel)
{
return (oldModel)
}
variation<-function(selectedPoints, model)
{
return (newPoints)
}
crossover<-function(parent1, parent2)
{
a<-runif(1)
parent1$x<-a*parent1$x+(1-a)*parent2$x
parent1$y<-a*parent1$y+(1-a)*parent2$y
#parent1$sigma_x<-a*parent1$sigma_x+(1-a)*parent2$sigma_x
#parent1$sigma_y<-a*parent1$sigma_y+(1-a)*parent2$sigma_y
return (parent1)
}
## particle swarm
## antlion
## the engine
aggregatedOperator<-function(history, oldModel)
{
selectedPoints<-selection(history, oldModel)
newModel<-modelUpdate(selectedPoints, oldModel)
newPoints<-variation(selectedPoints, newModel)
return (list(newPoints=newPoints,newModel=newModel))
}
metaheuristicRun<-function(initialization, startPoints, termination, evaluation)
{
history<-initialization(startPoints)
history<-evaluateList(history, evaluation)
# model<-initModel(history)
#while (!termination(history,model))
#{
#  aa<-aggregatedOperator(history, model)
#  aa$newPoints<-evaluateList(aa$newPoints, evaluation)
#  history<-historyPush(history,aa$newPoints)
#  model<-aa$newModel
#}
#return(history)
}
historyPush<-function(oldHistory, newPoints)
{
newHistory<-c(oldHistory,newPoints)
return (newHistory)
}
historyPop<-function(history, number)
{
stop=length(history)
start=max(stop-number+1,1)
return(history[start:stop])
}
evaluateList<-function(points,evaluation)
{
for (i in 1:length(points$x)) {
points$quality[[i]]<-evaluation(points$x[[i]], points$y[[i]])
}
return (points)
}
#commonFunctions
mi<-10
generateStartPoints<-function(mi)
{
startPoints<-data.frame(sigma_x=numeric(mi), sigma_y=numeric(mi), x=numeric(mi), y=numeric(mi), minimum=numeric(mi))
for (i in 1:mi)
{
startPoints$x[i]<-runif(1, -512, 512)
startPoints$y[i]<-runif(1, -512, 512)
startPoints$sigma_x[i]<-0.2
startPoints$sigma_y[i]<-0.2
startPoints$minimum[i]<-1000.0
startPoints$best_minimum[i]<-1000.0
}
return (startPoints)
}
termination<-function(i, n)
{
if (i <= n) {
return (F)
}
else {
return (T)
}
}
evaluation<-function(x, y)
{
return(x^2 + y^2)
}
initialization<-function(points){
historyPoints<-data.frame(points)
return (historyPoints)
}
########## funtion
library(ggplot2)
startPoints<-generateStartPoints(mi)
objectx<-metaheuristicRun(initialization, startPoints, termination, evaluation)
print(qplot(objectx$x, objectx$y))
#bla<-termination(3,2)
## evolutionary
selection<-function(history, model)
{
return(selectedPoints)
}
modelUpdate<-function(selectedPoints, oldModel)
{
return (oldModel)
}
variation<-function(selectedPoints, model)
{
return (newPoints)
}
crossover<-function(parent1, parent2)
{
a<-runif(1)
parent1$x<-a*parent1$x+(1-a)*parent2$x
parent1$y<-a*parent1$y+(1-a)*parent2$y
#parent1$sigma_x<-a*parent1$sigma_x+(1-a)*parent2$sigma_x
#parent1$sigma_y<-a*parent1$sigma_y+(1-a)*parent2$sigma_y
return (parent1)
}
## particle swarm
## antlion
## the engine
aggregatedOperator<-function(history, oldModel)
{
selectedPoints<-selection(history, oldModel)
newModel<-modelUpdate(selectedPoints, oldModel)
newPoints<-variation(selectedPoints, newModel)
return (list(newPoints=newPoints,newModel=newModel))
}
metaheuristicRun<-function(initialization, startPoints, termination, evaluation)
{
history<-initialization(startPoints)
history<-evaluateList(history, evaluation)
model<-initModel(history)
#while (!termination(history,model))
#{
#  aa<-aggregatedOperator(history, model)
#  aa$newPoints<-evaluateList(aa$newPoints, evaluation)
#  history<-historyPush(history,aa$newPoints)
#  model<-aa$newModel
#}
return(history)
}
historyPush<-function(oldHistory, newPoints)
{
newHistory<-c(oldHistory,newPoints)
return (newHistory)
}
historyPop<-function(history, number)
{
stop=length(history)
start=max(stop-number+1,1)
return(history[start:stop])
}
evaluateList<-function(points,evaluation)
{
for (i in 1:length(points$x)) {
points$quality[[i]]<-evaluation(points$x[[i]], points$y[[i]])
}
return (points)
}
#commonFunctions
mi<-10
generateStartPoints<-function(mi)
{
startPoints<-data.frame(sigma_x=numeric(mi), sigma_y=numeric(mi), x=numeric(mi), y=numeric(mi), minimum=numeric(mi))
for (i in 1:mi)
{
startPoints$x[i]<-runif(1, -512, 512)
startPoints$y[i]<-runif(1, -512, 512)
startPoints$sigma_x[i]<-0.2
startPoints$sigma_y[i]<-0.2
startPoints$minimum[i]<-1000.0
startPoints$best_minimum[i]<-1000.0
}
return (startPoints)
}
termination<-function(i, n)
{
if (i <= n) {
return (F)
}
else {
return (T)
}
}
evaluation<-function(x, y)
{
return(x^2 + y^2)
}
initialization<-function(points){
historyPoints<-data.frame(points)
return (historyPoints)
}
########## funtion
library(ggplot2)
startPoints<-generateStartPoints(mi)
objectx<-metaheuristicRun(initialization, startPoints, termination, evaluation)
print(qplot(objectx$x, objectx$y))
#bla<-termination(3,2)
## evolutionary
selection<-function(history, model)
{
return(selectedPoints)
}
modelUpdate<-function(selectedPoints, oldModel)
{
return (oldModel)
}
variation<-function(selectedPoints, model)
{
return (newPoints)
}
crossover<-function(parent1, parent2)
{
a<-runif(1)
parent1$x<-a*parent1$x+(1-a)*parent2$x
parent1$y<-a*parent1$y+(1-a)*parent2$y
#parent1$sigma_x<-a*parent1$sigma_x+(1-a)*parent2$sigma_x
#parent1$sigma_y<-a*parent1$sigma_y+(1-a)*parent2$sigma_y
return (parent1)
}
## particle swarm
## antlion
## the engine
aggregatedOperator<-function(history, oldModel)
{
selectedPoints<-selection(history, oldModel)
newModel<-modelUpdate(selectedPoints, oldModel)
newPoints<-variation(selectedPoints, newModel)
return (list(newPoints=newPoints,newModel=newModel))
}
metaheuristicRun<-function(initialization, startPoints, termination, evaluation)
{
history<-initialization(startPoints)
history<-evaluateList(history, evaluation)
model<-initModel(history)
#while (!termination(history,model))
#{
#  aa<-aggregatedOperator(history, model)
#  aa$newPoints<-evaluateList(aa$newPoints, evaluation)
#  history<-historyPush(history,aa$newPoints)
#  model<-aa$newModel
#}
return(history)
}
historyPush<-function(oldHistory, newPoints)
{
newHistory<-c(oldHistory,newPoints)
return (newHistory)
}
historyPop<-function(history, number)
{
stop=length(history)
start=max(stop-number+1,1)
return(history[start:stop])
}
evaluateList<-function(points,evaluation)
{
for (i in 1:length(points$x)) {
points$quality[[i]]<-evaluation(points$x[[i]], points$y[[i]])
}
return (points)
}
#commonFunctions
mi<-10
generateStartPoints<-function(mi)
{
startPoints<-data.frame(sigma_x=numeric(mi), sigma_y=numeric(mi), x=numeric(mi), y=numeric(mi), minimum=numeric(mi))
for (i in 1:mi)
{
startPoints$x[i]<-runif(1, -512, 512)
startPoints$y[i]<-runif(1, -512, 512)
startPoints$sigma_x[i]<-0.2
startPoints$sigma_y[i]<-0.2
startPoints$minimum[i]<-1000.0
startPoints$best_minimum[i]<-1000.0
}
return (startPoints)
}
termination<-function(i, n)
{
if (i <= n) {
return (F)
}
else {
return (T)
}
}
evaluation<-function(x, y)
{
return(x^2 + y^2)
}
initialization<-function(points){
historyPoints<-data.frame(points)
return (historyPoints)
}
initModel<-function(points){
historyPoints<-data.frame(points)
return (historyPoints)
}
########## funtion
library(ggplot2)
startPoints<-generateStartPoints(mi)
objectx<-metaheuristicRun(initialization, startPoints, termination, evaluation)
print(qplot(objectx$x, objectx$y))
#bla<-termination(3,2)
## evolutionary
selection<-function(history, model)
{
return(selectedPoints)
}
modelUpdate<-function(selectedPoints, oldModel)
{
return (oldModel)
}
variation<-function(selectedPoints, model)
{
return (newPoints)
}
crossover<-function(parent1, parent2)
{
a<-runif(1)
parent1$x<-a*parent1$x+(1-a)*parent2$x
parent1$y<-a*parent1$y+(1-a)*parent2$y
#parent1$sigma_x<-a*parent1$sigma_x+(1-a)*parent2$sigma_x
#parent1$sigma_y<-a*parent1$sigma_y+(1-a)*parent2$sigma_y
return (parent1)
}
## particle swarm
## antlion
## the engine
aggregatedOperator<-function(history, oldModel)
{
selectedPoints<-selection(history, oldModel)
newModel<-modelUpdate(selectedPoints, oldModel)
newPoints<-variation(selectedPoints, newModel)
return (list(newPoints=newPoints,newModel=newModel))
}
metaheuristicRun<-function(initialization, startPoints, termination, evaluation)
{
history<-initialization(startPoints)
history<-evaluateList(history, evaluation)
model<-initModel(history)
print(model)
#while (!termination(history,model))
#{
#  aa<-aggregatedOperator(history, model)
#  aa$newPoints<-evaluateList(aa$newPoints, evaluation)
#  history<-historyPush(history,aa$newPoints)
#  model<-aa$newModel
#}
return(history)
}
historyPush<-function(oldHistory, newPoints)
{
newHistory<-c(oldHistory,newPoints)
return (newHistory)
}
historyPop<-function(history, number)
{
stop=length(history)
start=max(stop-number+1,1)
return(history[start:stop])
}
evaluateList<-function(points,evaluation)
{
for (i in 1:length(points$x)) {
points$quality[[i]]<-evaluation(points$x[[i]], points$y[[i]])
}
return (points)
}
#commonFunctions
mi<-10
generateStartPoints<-function(mi)
{
startPoints<-data.frame(sigma_x=numeric(mi), sigma_y=numeric(mi), x=numeric(mi), y=numeric(mi), minimum=numeric(mi))
for (i in 1:mi)
{
startPoints$x[i]<-runif(1, -512, 512)
startPoints$y[i]<-runif(1, -512, 512)
startPoints$sigma_x[i]<-0.2
startPoints$sigma_y[i]<-0.2
startPoints$minimum[i]<-1000.0
startPoints$best_minimum[i]<-1000.0
}
return (startPoints)
}
termination<-function(i, n)
{
if (i <= n) {
return (F)
}
else {
return (T)
}
}
evaluation<-function(x, y)
{
return(x^2 + y^2)
}
initialization<-function(points){
historyPoints<-data.frame(points)
return (historyPoints)
}
initModel<-function(points){
historyPoints<-data.frame(points)
return (historyPoints)
}
########## funtion
library(ggplot2)
startPoints<-generateStartPoints(mi)
objectx<-metaheuristicRun(initialization, startPoints, termination, evaluation)
print(qplot(objectx$x, objectx$y))
#bla<-termination(3,2)
